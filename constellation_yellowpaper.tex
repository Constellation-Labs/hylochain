\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{float}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{A formal definition and statistical model checking of the constellation blockchain}
\author{Wyatt Meldman-Floch
\date{February 17 2018}
\setlength{\parskip}{1em}

\begin{document}
\maketitle

\begin{abstract}


\end{abstract}
\setcounter{secnumdepth}{0}
\section{Introduction}

\section{Fundamental Data Structures, Types and Functions}
\subsection{Tier $<$: Numeric}
Numeric type delineating tier within multi-tier hierarchy

\subsection{BlockData[Tier] $<$: $U$}
Consider a type $BlockData$ which serves as the parent type (under universal type $U$) of all data going on chain. All transactions, validator requests, meme data etc. All BlockData is equivalent via covariance and thus all BlockData can be compressed into a Block.

\subsection{Block[U] $<$: $U$}
Contains compressed form of Block Data. This is the result of consensus. Each unit of $BlockData$ must reference the previous round of consensus, this is satisfied by containing the $Block$ hash. It is worth noting that $Block[U] \equiv Block[BlockData[Tier]]$ through covariance. Block[U] is a Fix Point Type \footnote{https://jto.github.io/articles/typelevel-fix/}

\subsection{Transaction $<$: BlockData[0]}
Transaction is a subtype of BlockData that can only exist on the bottom tier. It is the building block of our currency.

\subsection{LeftHand $<$: RightHand $<$: Transaction}
Note: LeftHand and RightHand are symmetric subtypes of Transaction. For a Transaction to be valid it must be 'signed' by the counterparty. This is satisfied by sending a RightHand transaction that references a LeftHand transaction.

\subsection{Definition: Consensus Simplex, $\sigma$}
A set of validators, undergoing cryptographic consensus to produce a $Block$. Formally defined as a Simplex.
\begin{equation} \label{eq1}
\begin{split}
\sigma := collection[node]
\end{split}
\end{equation}

\subsection{Definition: Validator n}
A node that has 'woken up' by starting a $consensus$ process. It now gossips transactions to it's neighbors and is waiting to be selected as a Delegate.

\begin{equation} \label{eq1}
\begin{split}
n \in \sigma
\end{split}
\end{equation}

\subsection{Definition: Delegate}
A node who has been selected to perform consensus. Delegates are implicitly chosen, locally on each node via the Generating Function (see below). Once a new $Block$ is received, it is passed to the Generator Function, which tells this node if it is a delegate. A delegate is a node $n \in d$ such that

\begin{equation} \label{eq1}
\begin{split}
d \subset \sigma \ | \ g(Block, d) \rightarrow d
\end{split}
\end{equation}
where $g$ is the generating function below.

\subsection{Generating Function $g$}
This function is used to determine the next set of delegates from a given set of validators (consensus cluster) by selectively sampling a subset of nodes, based on reputation score and a probability distribution. See GURU for examples selective sampling via probability distribution.

\begin{equation} \label{eq1}
\begin{split}
g: (Block, \sigma) \rightarrow \phi \ | \ \phi \subseteq \sigma
\end{split}
\end{equation}


\subsection{Consensus (function) $f: \sigma \rightarrow  Block$}
A function that maps a consensus cluster to a Block. It follows that this is isomorphic to a catamorphism, with the collection being a cluster's mempool and the result the reduce being a Block.

\subsection{Node ADT}
let $n$ be an abstract data type Node, with three attributes, a $protocol$ process a $consensus$ process and a $chain$ class. The $protocol$ process handles transaction signing and essentially all functionality to send and receive payments. The $consensus$ process which implements the responsibilities of a validator node, is optional. Nodes can be 'sleepy', turning on the $consensus$ process at will. The $chain$ class is a local blockchain made up of all transactions/interactions with the chain that this node has made. Each link in the chain is a sub type of BlockData.

Formally we define $n$ as the algebraic data type

\begin{lstlisting}
case object Node {
  val chain: Chain = new Chain()
  val protocol: => Seq[BlockData[T]] = new Protocol()
  val consensus: =>  Block[U] = new Consensus()
}
\end{lstlisting}

\section{Network Topology}
We define the primitives of our network topology. We come to the conclusion that our network topology can be formally defined as a simplicial complex, specifically and ordered set of a special simplex called a Radial, which we define below. We define constellation's topology as an ordered set $C_K$ of Radials $R_t$, following ordering defined by Tier $t \in T$
\begin{equation} \label{eq1}
\begin{split}
C_K: \{R_0 \dots R_T \}
\end{split}
\end{equation}

\subsection{Simplex}
The clique complex of a graph G is a simplicial complex whose simplices are the cliques of G\footnote{https://arxiv.org/pdf/1007.0418.pdf}. We define a simplex $\sigma$ as a completely connected graph (clique) of constellation nodes, with which we can perform cryptographic consensus. Given $\sigma = \{n_0 \dots n_i\}$, $\sigma$ is a simplex iff:

1: $\sigma$ is a complete graph such that for a set of edges e, corresponding to nodes n,
\begin{equation} \label{eq1}
\begin{split}
\forall n \in \sigma, \exists e \in E \ | \ e \equiv \sigma \setminus \{n\} 
\end{split}
\end{equation}

Corollary: for each $n$ in a a simplex $\sigma_K$, the simplicial star\footnote{https://en.wikipedia.org/wiki/Simplicial_complex#Closure,_star,_and_link} of $n$, $st_K(n)$, for simplex $K$ is equivalent to the $\sigma_K$ that is:
\begin{equation} \label{eq1}
\begin{split}
\forall n \in \sigma_k, st_K(n) \equiv \sigma_K
\end{split}
\end{equation}

2: There exists a deterministic mapping given by an immutable generating function $g$
\begin{equation} \label{eq1}
\begin{split}
\exists g: \sigma \rightarrow d, \ | \ d \subseteq \sigma
\end{split}
\end{equation}

3: There exists the notion of a star cluster\footnote{https://arxiv.org/pdf/1007.0418.pdf} Such that star cluster $\sigma$ forms an independence complex of $K$.
\begin{equation} \label{eq1}
\begin{split}
SC(\sigma_k) = \bigcup_k st(n) \in I_G \ \forall k \in K
\end{split}
\end{equation}

Where $I_G$ is the set of all independence graphs of $K$\footnote{Definition 2.1 https://arxiv.org/pdf/1007.0418.pdf}. It follows from corollary (7) that

\begin{equation} \label{eq1}
\begin{split}
SC(\sigma_k) = \bigcup_k st(n) \\
\equiv st(n) \ \forall n \in k
\end{split}
\end{equation}

\subsection{Radials: Tiers of Hypergraphs}
A hypergraph represents an arbitrary set of subsets of it a graph's vertex set, where each subset is called a hyperedge\footnote{Pal S. et. al. http://www.facweb.iitkgp.ernet.in/~spp/geomgraph.pdf}. We define the the Radial abstract data type in terms of a hypergraph and mappings between vertex sets within that hypergraph. Specifically we define a Radial $R_j$ for given Tier $j \in \mathbb{N}$ (see above) such that

\begin{lstlisting}
case class Sigma(nodes: Node*)

type Radial[T <: Tier] {
/*
simplex and starCluster are hyperedges
*/
	val starCluster: Sigma[T-1]
	val simplex: Sigma[T]
	def hyperPlane[T1, T2] = Sigma[T1] => Sigma[T2]
	def route[T]: hyperPlane[T, T-1]
}
\end{lstlisting}

Our hypergraph for simplex $\sigma_k$ within Tier $t$ is given by
\begin{equation} \label{eq1}
\begin{split}
H_{t,k} = \{I_{g_{t-1}} \ | \ g_{t-1} \subset G_{t-1}, \sigma_k \}
\end{split}
\end{equation}

where $I_{g_{t-1}}$ is a subset of all simplexes in tier $t-1$ (as we know all simplexes are independent). $hyperPlane$ is a function that maps between two hyperedges, potentially across tiers. $route$ is a function that connects our two hyperedges with a $hyperPlane$ between Tier $t$ injectively to an independence complex in $t-1$. Note that $Sigma[T-1]$ and $I_{g_{t-1}}$ are equivalent via homotopy as shown in (5). 

In the degenerate case of our definition of $C_K$, namely when $C_K = \{R_0\}$, $starCluster$ is the mempool as defined below.

\section{Chain Topology}
We define the primitives of our DAG chain. We come to the conclusion that our network topology can be formally defined as a simplex graph with formal definition given by \footnote{def 3.1https://arxiv.org/pdf/1007.0418.pdf}.
\subsection{DAG of Chain Fibers}
The constellation blockchain is a DAG, where each node in the DAG is a simplex graph, composed of all nodes in the topological order preceding the current node. The nodes correspond to an undirected graph of chain fibers who will form a independence complex (mempool) upon which consensus can be performed.

\subsection{Chain Fibering}
We define the notion of chain fibers using a simplex graph. A chain fiber $C_k = \{\kappa(S) \dots \kappa(S_i) \}$ is a simplex graph made up of chain fibers in a preceding tier.

\subsection{Equivalence of Mempool to independent simplexes}
The Mempool of a consensus cluster is given by an independent set of all child simplexes routed by the

\subsection{Consensus, hyperplanes and delegate selection}
Delegate selection is a deterministic function and Consensus is a probabalistic function, both of which are defined on the surface of the hyperplane of a radial.


\section{Consensus and Underlying Protocol}
\subsection{Consensus}
Consensus is the process of forming a $Block$, it can be thought of as a function $f: \sigma \rightarrow Block$. Consensus clusters are formed in a tiered hierarchy. The top most tier forms the global state of the chain, which is made up of $Block$s from preceding tiers. Each tier, from top down until the second to last, has responsibility for routing transactions and validating the blocks from consensus clusters. 

\subsection{What is the lifecycle of a transaction}
When a transaction is sent, it is sent from a node to a higher tier which 'routes' the transaction to the consensus cluster(s) that host its 'shard', or the shard of the blockchain that host's it's public key's history. Each transaction has a left and right half. The initiator of the transaction sends the $LeftHalf$ to the network. Its $LeftHalf$ is then referenced by the $RightHalf$ which is sent by the counterparty.

\subsubsection{Why do we double sign?}
It preserves the notion of ordering. Scenario: I have 5 dollars, I send to two people. I send 5 to Wyatt and then 5 to Preston. I will need to wait until the top tier finishes consensus because both transactions are effectively 'racing' each other. Double signing allows us to preserve ordering (with high probability) without waiting for the total network to update state. Without this, consumer facing point of sale systems (think grocery store) are not possible; we would need to wait for a global state to reach consensus. Double siginig gives users the illusion of instant transaction confirmation.

\subsection{How is consensus performed}
Consensus $f: \sigma \rightarrow  Block$ is the act of creating notarized data in the form of $Blocks$. In our case, we are using the HoneyBadgerBFT, which prevents against sybil attacks using encryption \footnote{ch. 4.3 https://eprint.iacr.org/2016/199.pdf}. Nodes are rewarded based upon successful completion of consensus, the number of transactions they provide, and metadata about their performance. This is all calculated post facto by proof of meme and rewards are given within a set interval of blocks.

\subsubsection{How are delegates selected}
Delegates are selected locally, by passing the previous block into our Generating Function. This happens within the Consensus FSM.

\subsection{How is this secure/fit in with our incentive model}
Double spends across asynchronous consensus is prevented by double signing transactions. Consensus clusters are rewarded for processing transactions and sybil attacks are mitigated via encryption in honeybadgerBFT. We also are able theoretically improve typical byzantine fault tolerance over 40\% thanks to GURU and our reputation model. Ddos attacks can be mitigated via throttling of accounts with low reputation scores. I propose an incentive for routing where each node that routes a transaction signs the tx, and when a tx is notarized each account that routed the tx is given a reputation increase.

\bibliographystyle{plain}
\end{document}
