\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{float}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Hylochain and Chain Complexes}
\author{Wyatt Meldman-Floch}
\date{February 17 2018}
\setlength{\parskip}{1em}

\begin{document}
\maketitle

\begin{abstract}
We introduce Hylochain a DAG of blockchains. We show that a Hylochain is a chain complex within the homology theory of homotopy types. We propose the term Chain Complex to describe this class of cross chain distributed ledger technology.

\end{abstract}
\setcounter{secnumdepth}{0}
\section{Introduction}

\section{Fundamental Data Structures and Types}
\subsection{Tier $<$: Numeric}
Numeric type that is used to define ordering among the Radial functor (see below)

\subsection{BlockData[Tier] $<$: $U$}
Consider a type $BlockData$ which serves as the parent type (under universal type $U$) of all data going on chain. All BlockData is equivalent via covariance and thus all BlockData can be compressed into a Block.

\subsection{Block[U] $<$: $U$}
Contains compressed form of Block Data. This is the result of consensus. It is worth noting that $Block[U] \equiv Block[BlockData[Tier]]$ through covariance. Block[U] is a Fix Point Type \footnote{https://jto.github.io/articles/typelevel-fix/}

\subsection{Transaction $<$: BlockData[0]}
Transaction is a subtype of BlockData that can only exist on the bottom tier. It is the building block of our currency.

\subsection{Definition: Consensus Simplex, $\sigma$}
A set of validators, which undergo cryptographic consensus to produce a $Block$. Formally defined as a Simplex.
\begin{equation} \label{eq1}
\begin{split}
\sigma \cong collection[node]
\end{split}
\end{equation}

\subsection{Node ADT}
Let $n$ be an abstract data type Node, with three attributes, a $protocol$ process a $consensus$ process and a $chain$ class. Formally we define $n$ as the algebraic data type
\begin{lstlisting}
/*
should define algebraically eventually
*/
case object Node {
  val chain: Chain = new Chain()
  val protocol: => Seq[BlockData[T]] = new Protocol()
  val consensus: =>  Block[U] = new Consensus()
}
\end{lstlisting}

\section{Network Topology}
The network topology of a hylochain is a clique complex, and is formally defined as an ordered set of functors over the category of simplexes, $R_K$ of Radials $R_t$ ordered by Tier $t \in T$
\begin{equation} \label{eq1}
\begin{split}
R_K: \{R_0 \dots R_T \}
\end{split}
\end{equation}

\subsection{Simplex}
The clique complex of a graph G is a simplicial complex whose simplices are the cliques of G\footnote{https://arxiv.org/pdf/1007.0418.pdf}. We define a simplex $\sigma$ as a completely connected graph (clique) of nodes, with which we can perform cryptographic consensus. Given $\sigma = \{n_0 \dots n_i\}$, $\sigma$ is a simplex iff:

1: $\sigma$ is a complete graph such that for a set of edges e, corresponding to nodes n,
\begin{equation} \label{eq1}
\begin{split}
\forall n \in \sigma, \exists e \in E \ | \ e \equiv \sigma \setminus \{n\} 
\end{split}
\end{equation}

Corollary: for each $n$ in a a simplex $\sigma_K$, the simplicial star\footnote{Closure, star, and link: wikipedia/Simplicialcomplex} of $n$, $st_K(n)$, for simplex $K$ is equivalent to the $\sigma_K$ that is:
\begin{equation} \label{eq1}
\begin{split}
\forall n \in \sigma_k, st_K(n) \equiv \sigma_K
\end{split}
\end{equation}

2: There exists a deterministic mapping given by an immutable generating function $g$
\begin{equation} \label{eq1}
\begin{split}
\exists g: \sigma \rightarrow d, \ | \ d \subseteq \sigma
\end{split}
\end{equation}

3: There exists the notion of a star cluster\footnote{https://arxiv.org/pdf/1007.0418.pdf} Such that star cluster $\sigma$ forms an independence complex of $K$.
\begin{equation} \label{eq1}
\begin{split}
SC(\sigma_k) = \bigcup_k st(n) \in I_G \ \forall k \in K
\end{split}
\end{equation}

Where $I_G$ is the set of all independence graphs of $K$\footnote{Definition 2.1 https://arxiv.org/pdf/1007.0418.pdf}. It follows from corollary (4) that

\begin{equation} \label{eq1}
\begin{split}
SC(\sigma_k) = \bigcup_k st(n) \\
\equiv st(n) \ \forall n \in k
\end{split}
\end{equation}

\subsection{Radials: Tiered Hypergraphs}
A hypergraph represents an arbitrary set of subsets of it a graph's vertex set, where each subset is called a edge\footnote{Pal S. et. al. http://www.facweb.iitkgp.ernet.in/~spp/geomgraph.pdf}. We define the the Radial abstract data type in terms of a hypergraph and mappings between vertex sets within that hypergraph. Specifically for given Tier $t \in \mathbb{N}$ (see above), we define a Radial $R_t$ as a functor\footnote{https://typelevel.org/cats/typeclasses/functor.html} over the category of simplexes such that

\begin{lstlisting}
case class Sigma(nodes: Node*)

trait Radial[T <: Tier] {
/*
simplex and starCluster are hyperedges
*/
	val starCluster: Sigma[T-1]
	val simplices: Sigma[T]* \\ note this is variadic
	def hyperPlane[T1, T2]: Sigma[T1] => Sigma[T2]
}
\end{lstlisting}

The hypergraph for all simplexes $\sigma_k$ within Tier $t$ is given by the two element set
\begin{equation} \label{eq1}
\begin{split}
H_{t,k} = \{I_{g_{t-1}} \ | \ g_{t-1} \subset G_{t-1}, \sigma_k \}
\end{split}
\end{equation}

where $I_{g_{t-1}}$ is a subset of all simplexes in tier $t-1$ (as we know all simplexes are independent) and $\sigma_k \in R_t.simplices$. $hyperPlane$ is a function that maps between two hyperedges, potentially across tiers. Note that $Sigma[T-1]$ and $I_{g_{t-1}}$ are equivalent via homotopy as shown in Defnition 2.1 (footnote 5). 

In the degenerate case of our definition of $R_T$, namely when $R_t = \{R_0\}$, $starCluster$ is a mempool as defined below, but of transactions which are isomorphic to all subtypes of BlockData via covariance.

\section{Blockchain Topology}
We define the primitives of our DAG chain. We come to the conclusion that our DAG chain is a directed acyclic graph who's direction is given by simplex graph\footnote{wikipedia/Simplexgraph} $\kappa$ and topological ordering follows the tiered ordering of $R_K$. The simplex graph $\kappa(G)$ of an undirected graph G is itself a graph, with one node for each clique (a set of mutually adjacent vertices) in G. As all of our simplexes are independent, $\kappa_j \ | \ j \subseteq t-1$ for tier $t$ is formed as a disjoint subset of simplexes in $t-1$. We define $\kappa$ as a mapping from an undirected graph G to a new graph $\kappa(G)$ who's vertices are cliques and compositions of cliques of G
\begin{equation} \label{eq1}
\begin{split}
\kappa: \sigma_j \rightarrow \sigma_k \ | \ j \subset t-1, \sigma_k \in R_{t-1}.simplices
\end{split}
\end{equation}

\subsection{Chain Fibering}
Chain fibering is the formation of consensus blocks out of consensus blocks instead of transactions. This is varifiably sound up to isomorphism. We formulate notion of chain fibers by defining consensus in terms of a simplex graph $\kappa$. A chain fiber is given by 
\begin{equation} \label{eq1}
\begin{split}
f \circ \kappa_j^{k}: \sigma_k  \rightarrow Block_k
\end{split}
\end{equation}

where $\kappa_j^{k}$ is a simplex graph made up of chain fibers $Block_j$ in a preceding tier. The chain fibers from the preceding tier, $Block_j$, become the domain of the consensus function for tier k. We can say equivalently
\begin{equation} \label{eq1}
\begin{split}
c_k: \{Block \dots Block\}_j \rightarrow Block_k
\end{split}
\end{equation}

We can formally define the mempool $mem$ of simplex $\sigma_k$ in tier $t$ as 
\begin{equation} \label{eq1}
\begin{split}
mem_k \equiv \{Block \dots Block\}_j \ | \ j \subset R_{t-1}.simplices
\end{split}
\end{equation}

\section{Chain Complexes and Polymorphic Validation}
There is a namely notion in topology, the chain complex, which accurately describes the our network topology in relation to blockchain topology. We propose the definition of a Chain Complex, as a collection of blockchains that are connected, composed or scaled through chain fibering and/or parachains. We define chain fibers and parachains in terms of homological algebra over chain complexes and show how to "stich" these chains together through type equivalent validation protocols.

Validation is the cornerstone to blockchain technology. We show how to formulate a probability space upon which we can define and implement a probabilistic consensus mechanism.

First we define the space of hyperplanes between Radials and show that this is a metric space. Every metric space is also a topological space, so it serves us to first define $R_K$ as a topological space. It is trivial to show that $n \in k \forall K$, $\sigma$, Radial.$simplices$ satisfied the necessary axioms\footnote{http://mathworld.wolfram.com/TopologicalSpace.html} of a topological space and just as trivial to extend this to the union of simplices across Radials. We leave this as an exercise for the reader. 

The topological space we are interested in is actually a mixture of $n \in k \forall K$, $\sigma_k \in K$ and $R \in R_K$. Because $\sigma_k$ is an independence complex for all $k \in K$, we need to use the concept of homotopy to "stitch" these topologies together. We show that the Hylomorphism recursion scheme and it's parameterization via bialgebra allow us to "stitch" these topologies together under homotopy defined by typesafety.

From the beginning we have assumed homotopy equivalence, thus it follows up to isomorphism that if one Radial is a topological space, so is $R_K$
\begin{equation} \label{eq1}
\begin{split}
\exists R \in R_K \ | \ R \cong T \implies \forall R \in R_K,  R \cong T
\end{split}
\end{equation}
where T is a topological space. Since we know by definition that $R$ is a functor over the category of topological spaces it follows that $R_K$ constructs a chain complex under type equivalence\footnote{}. 

\begin{equation} \label{eq1}
\begin{split}
C_R = R_{0}{\xrightarrow {h_{0}}}R_{1} \dots R_{n-1}{\xrightarrow {h_{n-1}}}R_{n}
\end{split}
\end{equation}
where $h_{0}$ is a hylomorphism.

A hylomorphism can be defined in terms of algebras and coalgebras:
\begin{lstlisting}
def hylo[F[_] : Functor, A, B](f: F[B] => B)(g: A => F[A]): A => B =
  a => f(g(a) map hylo(f)(g))
\end{lstlisting}
Where g is an f-coalgebra and f is an f-algebra \footnote{http://free.cofree.io/2017/11/13/recursion/}. It is trivial to note that process of distributed consensus is isomorphic to a hylomorphism. 

\subsection{Hylomorphic Vector Space}
Cohomology is obtained if we reverse the arrows in a $C_R$. We are concerned Cohomology because we do not have the notion of a tensor product in the homology theory of homotopy types. However the cohomology of a wedge product between two spaces is isomorphic to the product of the cohomologies. \footnote{R. Cavallo, Theorem 4.6 https://www.cs.cmu.edu/~rwh/theses/cavallo.pdf}

\begin{equation} \label{eq1}
H_n(X \wedge Y) \cong H_n(X) \times H_n(Y)
\end{equation}

The product is a manifold from the wedge of spaces with isomorphic cohomology groups, which is enforced by homotopy type equivalence (TODO add proof, easy). As our metamorpism is a bialgebra it follows that a vector space can be formed\footnote{http://www.cs.ox.ac.uk/jeremy.gibbons/publications/metamorphisms-scp.pdf}. Naturally, we can create an inner product space of a homomorphic chain complex as follows

\begin{equation} \label{eq1}
H_n(X \wedge X) \cong H_n(X) \times H_n(X) = \langle X, X^* \rangle
\end{equation}

This vector space can be formally defined in terms of the hyperplanes between Radials (show, this is key), and furthermore referred to as "hylomorphic space". A hylomorphic space $H_n(X) \times H_n(X)$ is essentially an inner product space from which we can define a probability. It can be shown that a mixture of validation protocols can be formally defined in terms of the hylomorphic space.

\section{Infinite scalability through homomorphic parachains}
We show that the criteria for cross-chain liquidity allows us to recursively define an unbouded chain complex within the homology theory of homotopy types.

Our definition of the hylomorphic space implicitly showed that $R_K$ is a homology class within the homology theory of Homotopy types\footnote{https://arxiv.org/pdf/1706.01540.pdf}. It follows that $R_K$ forms a chain complex with homomorphism defined as type equivalence. A homology theory of $K_i$ types, where $H_n(-)$ is a functor \footnote{R. Grahm Theorem 34 https://arxiv.org/pdf/1706.01540.pdf}, is given by 
\begin{equation} \label{eq1}
\begin{split}
H_n(X) = || colim_i (X_i,\theta_i) ||_0
\end{split}
\end{equation}

It follows from our algebraic definition of a hylomorphism that we can construct a homology
\begin{equation} \label{eq1}
\begin{split}
H^{h}_n(X) = || colim_i (F_i, h_i) ||_0 \ | \ h_i: A \rightarrow B = g \circ f
\end{split}
\end{equation}
where h is a hylomorphism.

It follows that $R_K$ is isomorphic to $H^{h}_n$. Proof: show R is a functor over the category of simplexes and that hylomorphism between Radials is type equivalent.\footnote{ensure above definition satisfies criteria from R. Grahm}

\subsection{Typesafe Cross-chain Atomic Swaps}
\subsubsection{Definition of chain liquidity}
Two chain complexes are chain equivalent if there exists a homotopic mapping between them. We show how homotopy is constructed for a chain complex.

Proof: we know due to the univalence axiom that homotopy is implicit from type equivalence. We know from R. Grahm that a function from $|| colim_i (X_i,\theta_i) ||_0 \rightarrow || colim_i (X_i,\phi_i) ||_0$ where each $ X_i,Y_i $ is a set, it suffices to show that $f_i: X_i  \rightarrow Y_i$ such that $ f_i \circ \phi_i =  \theta_i \circ f_{i+1}$.

Thus we show that for two chain complexes with type equivalent functors, if their f-algebras are isomorphic, it follows that \footnote{https://www.seas.upenn.edu/~jean/sheaves-cohomology.pdf} (we can easily show with cw-complex, should add diagram)
\begin{equation}
f_i \circ \phi_i =  \theta_i \circ f_{i+1} = \theta_i \circ f_i =  \theta_i \circ \phi_i
\end{equation}

A tensor defines chain mappings\footnote{http://www.math.uni-frankfurt.de/~johannso/SkriptAll/SkriptTopAlg/SkriptTopChain/algtop4.pdf} and a path differential of 0 is required for homotopy. We do not have additivity which is required for a tensor, but we can get around this via the Exactness Axiom. We know that the path differential is 0 under type equivalence due to the univalence axiom, thus there exists homotopy.

Liquidity between multiple chains is isomorphic to the existence of a fibration, which is defined as $C: S \rightarrow Type$ where $C$ is a base type, and $S$ is a pointed set. This is analogous to classical topology where $C$ and $S$ are spaces. Due to the behavior of truncated colimits of sets\footnote{R. Grahm Remark33} it can be shown that for $ || colim_i (Y_i,\theta_i) ||_0 \rightarrow || colim_i (Z_i,\zeta_i) ||_0$ given a $g_i: Y_i  \rightarrow Z_i$ then $|| colim_i (X_i,\theta_i) ||_0 \rightarrow || colim_i (Z_i,\zeta_i) ||_0$ is given by $f \circ g$. If $f,g$ are isomorphic then there exists a homotopy and there exists a fibration. It follows that more complicated cross chain structures can be formed by mapping cones and mapping cylinders.

\subsection{Scaling through Recursive Parachains}
By definition $C_K$ is unbounded which implies that the chain complex is unbounded and our network bandwidth follows the following exponential formula:

\begin{equation} \label{eq1}
\begin{split}
f(x, n) \cong \alpha x \mod_n \\
U(f, x, t) = (c f(x, n)^t
\end{split}
\end{equation}
where $c, \alpha, n$ are scaling params. TODO, tie these together in our definition of Radial.

\subsection{Conclusion}
We have described Hylochain and the basic notion of a Chain Complex. We are inspired by the possibility of applying sheaf theory to construct vector fields\footnote{https://www.seas.upenn.edu/~jean/sheaves-cohomology.pdf} for a wide range of applications.

\bibliographystyle{plain}
\end{document}
