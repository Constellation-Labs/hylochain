\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{float}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Blockchain Cohomology}
\author{Wyatt Meldman-Floch}
\date{February 17 2018}
\setlength{\parskip}{1em}

\begin{document}
\maketitle

\begin{abstract}
We propose a blockchain cohomology theory based on the homology theory of homotopy types and use this to describe the fundamental features of the constellation blockchain.

\section{Blockchain Homotopy}
Lets start with a super simple type theoretic definition of a blockchain. Let $A$ be a type representing a transaction, $B$ represent the type of a block and $\rightarrow$ represent distributed consensus, let us define a blockchain by the following construction

\begin{equation} \label{eq1}
\begin{split}
A \xrightarrow{consensus} B
\end{split}
\end{equation}

If we define $A$ and $B$ as covariant subtypes of a universal type $U$, we can say that this blockchain is described by the homology theory of homotopy types. The magic that allows us to go from a simple type theoretic definition to homology is the notion of homotopy. Where $\pi_U$ is the homotopy group of our universal type and $Cov$ is covariance, homomorphism if given by

\begin{equation} \label{eq1} 
\begin{split}
Hom_{A, B} = Cov(A,B) \cong  \pi_B
\end{split}
\end{equation}

Now why does any of this matter? It matters because we now have a formal body of mathematical machinery with which we can build complex distributed ledgers. This allows us to formally define and different blockchains the same way we engineer fields in physics. This process is known as guage theory and constitutes the formation of a gauge field. However for our purpose, it shows us how to create sessionized streams of factual data using the tools of cohomology and sheaf theory. Cohomology in our case is measure of the deviation from homotopy, or how type $A$ and $B$ deviate under covariance. We now define the constellation blockchains in terms of the notion of a chain complex within the homology theory of homotopy types.

\section{Chain Complexes and the Constellation Blockchain}
There's an annoying problem about our arrow above, which is that there's only a fixed number of $A$'s that can be turned into a $B$. The constellation blockchain is a solution to this problem.

Using our type theoretic definition above, we can extend this notion of homotopy that connects $A$ and $B$ to create a chain complex, which for our purposes is an incrementally bigger blockchain. We define the constellation blockchain as a chain complex 
\begin{equation} \label{eq1}
\begin{split}
C_R = R_{0}{\xrightarrow {h_{0}}}R_{1} \dots R_{n-1}{\xrightarrow {h_{n-1}}}R_{n}
\end{split}
\end{equation}
where $R_{0 \dots N}$ are monads "carrying" blocks of type $U$ and $h_{0 \dots n-1}$ is a special type of consensus operator called a hylomorphism which preserves homotopy.


\subsection{Hylochain and Polymorphic Validation}
What allows us to construct $C_R$ is the homotopy equivalence between blocks $B$ and the transactions they're composed of, $A$. Since we described blockchains in terms of homotopy type theory, we used tools from category theory to define $C_R$, namely the notion of a monad, and recursion schemes.

\subsubsection{The Constellation DAG}
The Constellation chain complex $C_R$ is implemented as a directed acyclic graph of monads called Radials. The topological sorting of this DAG gives us the homology group of our topological space \footnote{https://arxiv.org/pdf/1605.07798.pdf}
\begin{align*}
Hom = \{\pi_0 \dots \pi_n \} \forall n \in \mathbb{N}
\end{align*}
where $\pi_n$ us the homotopy group of order $n$

\subsubsection{Radial Simplex}
As a blockchain is a distributed system, we can describe our simplex $R_N$ as a cluster of nodes partitioned into clique complexes.

Note we are forming a chain complex of monads. Those monads are implemented as simplicial complexes from which blocks are created. In this sense we are creating a cw-complex both of homotopy types and of simplexes. This allows us to define a partitioning logic for nodes to come and go from radials separate from the nodes themselves. the way we do this is by implementing the monads in terms of re ursion schemes. We define mappings between simplices in terms of the ypes of the hylomorphism. Implementing the simplicial chain complex using recusion schemes allows us to define a simplicial complex with the ease of type safety. We merely bake the rules into the type of the blocks. Specifically, instead of trying to describe this all in terms of simplicial complexes, we use the fact that we can form a Serre fibration or a weak fibration, using homotopy type theory which effectively allows us to encode the logic for our dynamically partitioned network within the blocks themselves. The way we do that is by constructing our blocks as sheaves



 The clique complex of a graph G is a simplicial complex whose simplices are the cliques of G\footnote{https://arxiv.org/pdf/1007.0418.pdf}. We define a simplex $\sigma$ as a completely connected graph (clique) of nodes, with which we can perform cryptographic consensus. Given $\sigma = \{n_0 \dots n_i\}$, $\sigma$ is a Radial simplex iff:

1: $\sigma$ is a complete graph such that for a set of edges e, corresponding to nodes n,
\begin{equation} \label{eq1}
\begin{split}
\forall n \in \sigma, \exists e \in E \ | \ e \equiv \sigma \setminus \{n\} 
\end{split}
\end{equation}

Corollary: for each $n$ in a a simplex $\sigma_K$, the simplicial star\footnote{Closure, star, and link: wikipedia/Simplicialcomplex} of $n$, $st_K(n)$, for simplex $K$ is equivalent to the $\sigma_K$ that is:
\begin{equation} \label{eq1}
\begin{split}
\forall n \in \sigma_k, st_K(n) \equiv \sigma_K
\end{split}
\end{equation}

2: There exists a deterministic mapping given by an immutable generating function $g$
\begin{equation} \label{eq1}
\begin{split}
\exists g: \sigma \rightarrow d, \ | \ d \subseteq \sigma
\end{split}
\end{equation}

3: There exists the notion of a star cluster\footnote{https://arxiv.org/pdf/1007.0418.pdf} Such that star cluster $\sigma$ forms an independence complex of $K$.
\begin{equation} \label{eq1}
\begin{split}
SC(\sigma_k) = \bigcup_k st(n) \in I_G \ \forall k \in K
\end{split}
\end{equation}

Where $I_G$ is the set of all independence graphs of $K$\footnote{Definition 2.1 https://arxiv.org/pdf/1007.0418.pdf}. It follows from corollary (4) that

\begin{equation} \label{eq1}
\begin{split}
SC(\sigma_k) = \bigcup_k st(n) \\
\equiv st(n) \ \forall n \in k
\end{split}
\end{equation}

A hypergraph represents an arbitrary set of subsets of it a graph's vertex set, where each subset is called a edge\footnote{Pal S. et. al. http://www.facweb.iitkgp.ernet.in/~spp/geomgraph.pdf}. We define the the Radial abstract data type in terms of a hypergraph and mappings between vertex sets within that hypergraph. Specifically for given Tier $t \in \mathbb{N}$ (see above), we define the Radial monoid\footnote{https://ncatlab.org/nlab/show/monoid} $R_t$ as a functor\footnote{https://typelevel.org/cats/typeclasses/functor.html} over the category of simplexes such that

\begin{align*}
R^{n}_k: \\ &
starCluster: \{R^{n-1}_0 \dots R^{n-1}_j\} | j \subset k, \\ &
state: \{A\}, \\ &
hyperplane: \{n_0 \dots n_k\}_{n-1} \rightarrow \{n_0 \dots n_k\}_n , \\ \\
\end{align*}

The hypergraph for all simplexes $\sigma_k$ within Order $O$ is given by the two element set
\begin{equation} \label{eq1}
\begin{split}
H_{t,k} = \{I_{g_{t-1}} \ | \ g_{t-1} \subset G_{t-1}, \sigma_k \}
\end{split}
\end{equation}

where $I_{g_{t-1}}$ is a subset of all simplexes in tier $t-1$ (as we know all simplexes are independent) and $\sigma_k \in R_t.simplices$. $hyperPlane$ is a function that maps between two hyperedges, potentially across tiers. Note that $Sigma[T-1]$ and $I_{g_{t-1}}$ are equivalent via homotopy as shown in Defnition 2.1 (footnote 5). 

In the degenerate case of our definition of $R_T$, namely when $R_t = \{R_0\}$, $starCluster$ is a mempool as defined below, or the set of all states shared amongst $\sigma_k$.


\subsection{Typesafe Cross-chain Atomic Swaps}
\subsubsection{Definition of chain liquidity}
Two chain complexes are chain equivalent if there exists a homotopic mapping between them. We show how homotopy is constructed for a chain complex.

Proof: we know due to the univalence axiom that homotopy is implicit from type equivalence. We know from R. Grahm that a function from $|| colim_i (X_i,\theta_i) ||_0 \rightarrow || colim_i (X_i,\phi_i) ||_0$ where each $ X_i,Y_i $ is a set, it suffices to show that $f_i: X_i  \rightarrow Y_i$ such that $ f_i \circ \phi_i =  \theta_i \circ f_{i+1}$.

Thus we show that for two chain complexes with type equivalent functors, if their f-algebras are isomorphic, it follows that \footnote{https://www.seas.upenn.edu/~jean/sheaves-cohomology.pdf} (we can easily show with cw-complex, should add diagram)
\begin{equation}
f_i \circ \phi_i =  \theta_i \circ f_{i+1} = \theta_i \circ f_i =  \theta_i \circ \phi_i
\end{equation}

A tensor defines chain mappings\footnote{http://www.math.uni-frankfurt.de/~johannso/SkriptAll/SkriptTopAlg/SkriptTopChain/algtop4.pdf} and a path differential of 0 is required for homotopy. We do not have additivity which is required for a tensor, but we can get around this via the Exactness Axiom. We know that the path differential is 0 under type equivalence due to the univalence axiom, thus there exists homotopy.

Liquidity between multiple chains is isomorphic to the existence of a fibration, which is defined as $C: S \rightarrow Type$ where $C$ is a base type, and $S$ is a pointed set. This is analogous to classical topology where $C$ and $S$ are spaces. Due to the behavior of truncated colimits of sets\footnote{R. Grahm Remark33} it can be shown that for $ || colim_i (Y_i,\theta_i) ||_0 \rightarrow || colim_i (Z_i,\zeta_i) ||_0$ given a $g_i: Y_i  \rightarrow Z_i$ then $|| colim_i (X_i,\theta_i) ||_0 \rightarrow || colim_i (Z_i,\zeta_i) ||_0$ is given by $f \circ g$. If $f,g$ are isomorphic then there exists a homotopy and there exists a fibration. It follows that more complicated cross chain structures can be formed by mapping cones and mapping cylinders.

\subsection{Chain fibering: Scaling through Recursive Parachains}
The simplex graph $\kappa(G)$ of an undirected graph G is itself a graph, with one node for each clique (a set of mutually adjacent vertices) in G. As all of our simplexes are independent, $\kappa_j \ | \ j \subseteq t-1$ for tier $t$ is formed as a disjoint subset of simplexes in $t-1$. We define $\kappa$ as a mapping from an undirected graph G to a new graph $\kappa(G)$ who's vertices are cliques and compositions of cliques of G
\begin{equation} \label{eq1}
\begin{split}
\kappa: \sigma_j \rightarrow \sigma_k \ | \ j \subset t-1, \sigma_k \in R_{t-1}.simplices
\end{split}
\end{equation}


Chain fibering is the formation of consensus blocks out of consensus blocks instead of transactions. This is varifiably sound up to isomorphism. We formulate notion of chain fibers by defining consensus in terms of a simplex graph $\kappa$. A chain fiber is given by 
\begin{equation} \label{eq1}
\begin{split}
f \circ \kappa_j^{k}: \sigma_k  \rightarrow Block_k
\end{split}
\end{equation}

where $\kappa_j^{k}$ is a simplex graph made up of chain fibers $Block_j$ in a preceding tier. The chain fibers from the preceding tier, $Block_j$, become the domain of the consensus function for tier k. We can say equivalently
\begin{equation} \label{eq1}
\begin{split}
c_k: \{Block \dots Block\}_j \rightarrow Block_k
\end{split}
\end{equation}

We can formally define the mempool $mem$ of simplex $\sigma_k$ in tier $t$ as 
\begin{equation} \label{eq1}
\begin{split}
mem_k \equiv \{Block \dots Block\}_j \ | \ j \subset R_{t-1}.simplices
\end{split}
\end{equation}

\subsection{Block Sheaves}
\footnote{\footnote{http://hamilton.nuigalway.ie/HPT/romero.pdf}}
Equivalence is given by pertubation. 

The application of the hylomorphic recursion scheme forms a chain complex and use its dualistic construction with the metamorphic recursion scheme to create a probability space space in terms of f-co/algebras. 

As our chain complex is defined in terms of homotopy types, we can use our f-co/algebras and the fact that we can crate a "combinatorial space", in order to define cohomology probabalistically. This allows us to analyze the robustness of cryptographic schemes using statistical model checking.

\footnote{\url{https://www.seas.upenn.edu/~jean/sheaves-cohomology.pdf}}\footnote{\url{https://arxiv.org/pdf/1303.3255.pdf}}
From the beginning we have assumed homotopy equivalence, thus it follows up to isomorphism that if one Radial is a topological space, so is $R_K$
\begin{equation} \label{eq1}
\begin{split}
\exists R \in R_K \ | \ R \cong T \implies \forall R \in R_K,  R \cong T
\end{split}
\end{equation}
where T is a topological space. Since we know by definition that $R$ is a functor over the category of topological spaces (via definition as a topological monad) it follows that $R_K$ constructs a chain complex under type equivalence\footnote{}. 

\subsection{Stitching Topological Spaces}
Cohomology is obtained if we reverse the arrows in a $C_R$. We are concerned Cohomology because we do not have the notion of a tensor product in the homology theory of homotopy types. However the cohomology of a wedge product between two spaces is isomorphic to the product of the cohomologies. \footnote{R. Cavallo, Theorem 4.6 https://www.cs.cmu.edu/~rwh/theses/cavallo.pdf}

\begin{equation} \label{eq1}
H_n(X \wedge Y) \cong H_n(X) \times H_n(Y)
\end{equation}
$\otimes$
The product is a manifold from the wedge of spaces with isomorphic cohomology groups, which is enforced by homotopy type equivalence (TODO add proof, easy). As our metamorpism is a bialgebra it follows that a vector space can be formed\footnote{http://www.cs.ox.ac.uk/jeremy.gibbons/publications/metamorphisms-scp.pdf}. Naturally, we can create an inner product space of a homomorphic chain complex as follows

\begin{equation} \label{eq1}
H_n(X \wedge X) \cong H_n(X) \times H_n(X) = \langle X, X^* \rangle
\end{equation}

This vector space can be formally defined in terms of the hyperplanes between Radials (show, this is key), and furthermore referred to as "hylomorphic space". A hylomorphic space $H_n(X) \times H_n(X)$ is essentially an inner product space from which we can define a probability. It can be shown that a mixture of validation protocols can be formally defined in terms of the hylomorphic space.


\subsection{Infinite scalability with homomorphic parachains}
We show that the criteria for cross-chain liquidity allows us to recursively define an unbouded chain complex within the homology theory of homotopy types.

Our definition of the hylomorphic space implicitly showed that $R_K$ is a homology class within the homology theory of Homotopy types\footnote{https://arxiv.org/pdf/1706.01540.pdf}. It follows that $R_K$ forms a chain complex with homomorphism defined as type equivalence. A homology theory of $K_i$ types, where $H_n(-)$ is a functor \footnote{R. Grahm Theorem 34 https://arxiv.org/pdf/1706.01540.pdf}, is given by 
\begin{equation} \label{eq1}
\begin{split}
H_n(X) = || colim_i (X_i,\theta_i) ||_0
\end{split}
\end{equation}

It follows from our algebraic definition of a hylomorphism that we can construct a homology
\begin{equation} \label{eq1}
\begin{split}
H^{h}_n(X) = || colim_i (F_i, h_i) ||_0 \ | \ h_i: A \rightarrow B = g \circ f
\end{split}
\end{equation}
where h is a hylomorphism.

It follows that $R_K$ is isomorphic to $H^{h}_n$. Proof: show through our definition of R as a monad that R is a functor over the category of simplexes and that hylomorphism between Radials preserves type homotopy through type equivalence.\footnote{ensure above definition satisfies criteria from R. Grahm}

By definition $C_K$ is unbounded which implies that the chain complex is unbounded and our network bandwidth follows the following exponential formula:

\begin{equation} \label{eq1}
\begin{split}
f(x, n) \cong \alpha x \mod_n \\
U(f, x, t) = (c f(x, n)^t
\end{split}
\end{equation}
where $c, \alpha, n$ are scaling params. TODO, tie these together in our definition of Radial.


\section{Conclusion and Applications}
https://golem.ph.utexas.edu/category/2012/09/general_covariance_in_homotopy.html


Information geometry is the holy grail of ml. But we can't build models that fine tuned because of junk data. The free flowing wellspring of factual data points will allow for the masses to compete with uber and google in a maketplace of ml apps. Tying everything back to our original simple type theoretic definition, if we have a universal type systems for blockcahins, enforced by compiler pugins for all languages, we get two major benefits. One is compile time checks of cross chain liquidity and the second is the ability to use functional programming techniques to implement blockchain protocols. As an example, we can show that consensus is actually just a flatmap over a a monad of defined as a cluster of nodes acting as the carrier for distributed consensus.

\url{https://homepages.inf.ed.ac.uk/rsarkar/papers/hyperbolic.pdf}

\end{abstract}
\setcounter{secnumdepth}{0}
\section{Introduction}

\bibliographystyle{plain}
\end{document}
